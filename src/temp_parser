# -----------------------------------------------------------------------------
# temporary parser out of class to get parser.out table
# b_vyking_parser.py
# authors : Robin Keunen, Pierre Vyncke
# -----------------------------------------------------------------------------

import logging
import sys
import ast
import ply.yacc as yacc
from src.indent_filter import IndentFilter
from src.ply import lex
from src.test_units import inputs
from src.b_vyking_lexer import BasicVykingLexer

sys.path.insert(0, "../..")

# helper function
def new_token(token_type, lineno):
    """Returns new token

    Args:
        type -- token type
        lineno -- line number of token
    """
    tok = lex.LexToken()
    tok.type = token_type
    tok.value = None
    tok.lineno = lineno
    tok.lexpos = mylexer.get_lexpos()
    return tok

mylexer = IndentFilter(BasicVykingLexer())
tokens = mylexer.tokens

precedence = (
    ('nonassoc', 'unmatched_if'),
    ('nonassoc', 'ELSE'),
    ('nonassoc', 'ELIF'),
    ('left', 'AND', 'OR'),
    ('nonassoc', 'NOT'),
    ('left', 'PLUS', 'MINUS'),
    ('left', 'TIMES', 'DIVIDE', 'MOD'),
    ('right', 'UMINUS')  # unary minus operator
)


def p_empty(p):
    'empty :'
    pass


def p_vyking_input(p):
    'vyking_input : statement_sequence ENDMARKER'
    p[0] = p[1]


def p_statement_sequence(p):
    """
    statement_sequence : statement statement_sequence
                       | statement
    """
    # tuple of the statements
    if len(p) == 3:
        p[0] = ast.Statement_sequence(p[1], p[2])
    else:
        p[0] = ast.Statement_sequence(p[1])


def p_statement(p):
    """
    statement : simple_statement
              | compound_statement
    """
    p[0] = p[1]


def p_simple_statement(p):
    """
    simple_statement : assignment NEWLINE
                     | return_statement NEWLINE
                     | funcall NEWLINE
    """
    p[0] = p[1]


def p_compound_statement(p):
    """
    compound_statement : if_statement
                       | while_statement
                       | fundef
    """
    p[0] = p[1]


def p_assignment(p):
    """
    assignment : ID ASSIGN clause
               | ID INC expression
               | ID DEC expression
    """
    if p[2] == '=':
        p[0] = ast.Assignment(p[1], p[3])
    elif p[2] == '+=':
        p[0] = ast.Assignment(p[1], ast.Expression(p[1], "PLUS", p[3]))
    elif p[2] == '-=':
        p[0] = ast.Assignment(p[1], ast.Expression(p[1], "MINUS", p[3]))


def p_return_statement(p):
    'return_statement : RETURN expression'
    p[0] = ast.Return(p[2])


def p_funcall(p):
    """
    funcall : ID LPAREN args RPAREN
            | ID LPAREN RPAREN
    """
    if len(p) == 5:
        p[0] = ast.Funcall(ast.ID(p[1]), p[3])
    else:
        p[0] = ast.Funcall(ast.ID(p[1]))


def p_args(p):
    """
    args : args COMMA clause
         | clause
    """
    if len(p) == 4:
        p[0] = p[1] + [p[3]]
    else:
        p[0] = [p[1]]


def p_if_statement(p):
    """
    if_statement : IF clause COLON suite if_closure
    """
    p[0] = ast.If(p[2], p[4], p[5])


def p_if_closure(p):
    """
    if_closure : elif_statement %prec ELIF
               | ELSE COLON suite
    """
    if len(p) == 2:
        p[0] = p[1]
    else:
        p[0] = ast.Else(p[3])


def p_if_closure_empty(p):
    'if_closure : empty %prec unmatched_if'
    p[0] = p[1]


def p_elif_statement(p):
    'elif_statement : ELIF clause COLON suite if_closure'
    p[0] = ast.Elif(p[2], p[4], p[5])


def p_while_statement(p):
    'while_statement : WHILE clause COLON suite'
    p[0] = ast.While(p[2], p[4])


def p_fundef(p):
    'fundef : DEFUN ID LPAREN parameters RPAREN COLON suite'
    p[0] = ast.Fundef(ast.ID(p[2]), p[7], p[4])


def p_parameters(p):
    """
    parameters : parameters COMMA ID
               | ID
    """
    if len(p) == 4:
        p[0] = p[1] + [ast.ID(p[3])]
    else:
        p[0] = [ast.ID(p[1])]


def p_suite(p):
    """
    suite : simple_statement
          | NEWLINE INDENT statement_sequence DEDENT
    """
    if len(p) == 2:
        p[0] = p[1]
    else:
        p[0] = p[3]


def p_clause(p):
    """
    clause : NOT clause
         | LPAREN clause RPAREN
         | clause OR clause
         | clause AND clause
         | expression EQ expression
         | expression NEQ expression
         | expression LT expression
         | expression GT expression
         | expression GEQ expression
         | expression LEQ expression
    """
    if len(p) == 3:
        p[0] = ast.Clause(None, "NOT", p[2])
    elif p[1] == '(':
        p[0] = p[2]
    elif p[2] == 'or':
        p[0] = ast.Clause(p[1], "OR", p[3])
    elif p[2] == 'and':
        p[0] = ast.Clause(p[1], "AND", p[3])
    elif p[2] == '==':
        p[0] = ast.Clause(p[1], "EQ", p[3])
    elif p[2] == '!=':
        p[0] = ast.Clause(p[1], "NEQ", p[3])
    elif p[2] == '<':
        p[0] = ast.Clause(p[1], "LT", p[3])
    elif p[2] == '>':
        p[0] = ast.Clause(p[1], "GT", p[3])
    elif p[2] == '<=':
        p[0] = ast.Clause(p[1], "LEQ", p[3])
    elif p[2] == '>=':
        p[0] = ast.Clause(p[1], "GEQ", p[3])


def p_clause_exp(p):
    'clause : expression'
    p[0] = p[1]


def p_expression_binop(p):
    """
    expression : expression PLUS expression
               | expression MINUS expression
               | expression TIMES expression
               | expression DIVIDE expression
               | expression MOD expression
    """
    #print [repr(p[i]) for i in range(0,4)]
    if p[2] == '+':
        p[0] = ast.Expression(p[1], 'PLUS', p[3])
    elif p[2] == '-':
        p[0] = ast.Expression(p[1], 'MINUS', p[3])
    elif p[2] == '*':
        p[0] = ast.Expression(p[1], 'TIMES', p[3])
    elif p[2] == '/':
        p[0] = ast.Expression(p[1], 'DIVIDE', p[3])
    elif p[2] == '%':
        p[0] = ast.Expression(p[1], 'MOD', p[3])



def p_expression_uminus(p):
    'expression : MINUS expression %prec UMINUS'
    p[0] = ast.Expression(None, 'UMINUS', p[2])


# def p_expression_group(p):
#     'expression : LPAREN expression RPAREN'
#     p[0] = p[2]


def p_expression_numeric(p):
    'expression : numeric'
    p[0] = p[1]


def p_numeric_int(p):
    'numeric : INT'
    p[0] = ast.Vinteger(p[1])


def p_numeric_float(p):
    'numeric : FLOAT'
    p[0] = ast.Vfloat(p[1])


def p_expression_id(p):
    'expression : ID'
    p[0] = ast.ID(p[1])


def p_expression_string(p):
    'expression : STRING'
    p[0] = ast.Vstring(p[1])


def p_expression_funcall(p):
    'expression : funcall'
    p[0] = p[1]

def p_expression_boolean(p):
    'expression : BOOLEAN'
    p[0] = ast.Vboolean(p[1])

# Error rule for syntax errors.
def p_error(p):
    if p is None:
        print("fix for missing line")
        parser.errok()
        return new_token("ENDMARKER", mylexer.get_lineno())
    elif p.type == "ENDMARKER":
        print("line %d: Missing new line at end of file." % p.lineno)
        p.lexer.lookahead = p
        parser.errok()
        return new_token("NEWLINE", p.lineno)
    else:
        print('line %d: Syntax error when reading %s:%s ' % (p.lineno, p.type, p.value))


# Usage
if __name__ == "__main__":

    data = inputs["find_bounds"]

    # logger object
    logging.basicConfig(
        level=logging.DEBUG,
        filename="parselog.txt",
        filemode="w",
        format="%(message)s"
    )
    log = logging.getLogger()

    parser = yacc.yacc(debug=log, start="vyking_input")
    result = parser.parse(data, lexer=mylexer, debug=log)

    lineno = 1
    for line in data.split('\n'):
        print("%d: %s" % (lineno, line))
        lineno += 1
    print()

    print(result)
