Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> vyking_input
Rule 1     empty -> <empty>
Rule 2     vyking_input -> statement_sequence ENDMARKER
Rule 3     statement_sequence -> statement statement_sequence
Rule 4     statement_sequence -> statement
Rule 5     statement -> simple_statement
Rule 6     statement -> compound_statement
Rule 7     simple_statement -> assignment NEWLINE
Rule 8     simple_statement -> return_statement NEWLINE
Rule 9     simple_statement -> funcall NEWLINE
Rule 10    compound_statement -> if_statement
Rule 11    compound_statement -> while_statement
Rule 12    compound_statement -> fundef
Rule 13    assignment -> ID ASSIGN clause
Rule 14    assignment -> ID INC expression
Rule 15    assignment -> ID DEC expression
Rule 16    return_statement -> RETURN expression
Rule 17    funcall -> ID LPAREN args RPAREN
Rule 18    funcall -> ID LPAREN RPAREN
Rule 19    args -> args COMMA clause
Rule 20    args -> clause
Rule 21    if_statement -> IF clause COLON suite if_closure
Rule 22    if_closure -> elif_statement
Rule 23    if_closure -> ELSE COLON suite
Rule 24    if_closure -> empty
Rule 25    elif_statement -> ELIF clause COLON suite if_closure
Rule 26    while_statement -> WHILE clause COLON suite
Rule 27    fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite
Rule 28    parameters -> parameters COMMA ID
Rule 29    parameters -> ID
Rule 30    suite -> simple_statement
Rule 31    suite -> NEWLINE INDENT statement_sequence DEDENT
Rule 32    clause -> NOT clause
Rule 33    clause -> LPAREN clause RPAREN
Rule 34    clause -> clause OR clause
Rule 35    clause -> clause AND clause
Rule 36    clause -> expression EQ expression
Rule 37    clause -> expression NEQ expression
Rule 38    clause -> expression LT expression
Rule 39    clause -> expression GT expression
Rule 40    clause -> expression GEQ expression
Rule 41    clause -> expression LEQ expression
Rule 42    clause -> expression
Rule 43    expression -> expression PLUS expression
Rule 44    expression -> expression MINUS expression
Rule 45    expression -> expression TIMES expression
Rule 46    expression -> expression DIVIDE expression
Rule 47    expression -> expression MOD expression
Rule 48    expression -> MINUS expression
Rule 49    expression -> numeric
Rule 50    numeric -> INT
Rule 51    numeric -> FLOAT
Rule 52    expression -> ID
Rule 53    expression -> STRING
Rule 54    expression -> funcall
Rule 55    expression -> BOOLEAN

Terminals, with rules where they appear

AND                  : 35
ASSIGN               : 13
BOOLEAN              : 55
COLON                : 21 23 25 26 27
COMMA                : 19 28
DEC                  : 15
DEDENT               : 31
DEFUN                : 27
DIVIDE               : 46
ELIF                 : 25
ELSE                 : 23
ENDMARKER            : 2
EQ                   : 36
FLOAT                : 51
GEQ                  : 40
GT                   : 39
ID                   : 13 14 15 17 18 27 28 29 52
IF                   : 21
INC                  : 14
INDENT               : 31
INT                  : 50
LEQ                  : 41
LPAREN               : 17 18 27 33
LT                   : 38
MINUS                : 44 48
MOD                  : 47
NEQ                  : 37
NEWLINE              : 7 8 9 31
NOT                  : 32
OR                   : 34
PLUS                 : 43
RETURN               : 16
RPAREN               : 17 18 27 33
STRING               : 53
TIMES                : 45
WHILE                : 26
error                : 

Nonterminals, with rules where they appear

args                 : 17 19
assignment           : 7
clause               : 13 19 20 21 25 26 32 33 34 34 35 35
compound_statement   : 6
elif_statement       : 22
empty                : 24
expression           : 14 15 16 36 36 37 37 38 38 39 39 40 40 41 41 42 43 43 44 44 45 45 46 46 47 47 48
funcall              : 9 54
fundef               : 12
if_closure           : 21 25
if_statement         : 10
numeric              : 49
parameters           : 27 28
return_statement     : 8
simple_statement     : 5 30
statement            : 3 4
statement_sequence   : 2 3 31
suite                : 21 23 25 26 27
vyking_input         : 0
while_statement      : 11

Parsing method: LALR

state 0

    (0) S' -> . vyking_input
    (2) vyking_input -> . statement_sequence ENDMARKER
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    vyking_input                   shift and go to state 1
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 4
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 1

    (0) S' -> vyking_input .



state 2

    (5) statement -> simple_statement .

    ID              reduce using rule 5 (statement -> simple_statement .)
    RETURN          reduce using rule 5 (statement -> simple_statement .)
    IF              reduce using rule 5 (statement -> simple_statement .)
    WHILE           reduce using rule 5 (statement -> simple_statement .)
    DEFUN           reduce using rule 5 (statement -> simple_statement .)
    DEDENT          reduce using rule 5 (statement -> simple_statement .)
    ENDMARKER       reduce using rule 5 (statement -> simple_statement .)


state 3

    (27) fundef -> DEFUN . ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 17


state 4

    (2) vyking_input -> statement_sequence . ENDMARKER

    ENDMARKER       shift and go to state 18


state 5

    (9) simple_statement -> funcall . NEWLINE

    NEWLINE         shift and go to state 19


state 6

    (26) while_statement -> WHILE . clause COLON suite
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 20
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 31

state 7

    (16) return_statement -> RETURN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 32
    numeric                        shift and go to state 21

state 8

    (6) statement -> compound_statement .

    ID              reduce using rule 6 (statement -> compound_statement .)
    RETURN          reduce using rule 6 (statement -> compound_statement .)
    IF              reduce using rule 6 (statement -> compound_statement .)
    WHILE           reduce using rule 6 (statement -> compound_statement .)
    DEFUN           reduce using rule 6 (statement -> compound_statement .)
    DEDENT          reduce using rule 6 (statement -> compound_statement .)
    ENDMARKER       reduce using rule 6 (statement -> compound_statement .)


state 9

    (8) simple_statement -> return_statement . NEWLINE

    NEWLINE         shift and go to state 33


state 10

    (11) compound_statement -> while_statement .

    ID              reduce using rule 11 (compound_statement -> while_statement .)
    RETURN          reduce using rule 11 (compound_statement -> while_statement .)
    IF              reduce using rule 11 (compound_statement -> while_statement .)
    WHILE           reduce using rule 11 (compound_statement -> while_statement .)
    DEFUN           reduce using rule 11 (compound_statement -> while_statement .)
    DEDENT          reduce using rule 11 (compound_statement -> while_statement .)
    ENDMARKER       reduce using rule 11 (compound_statement -> while_statement .)


state 11

    (3) statement_sequence -> statement . statement_sequence
    (4) statement_sequence -> statement .
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ENDMARKER       reduce using rule 4 (statement_sequence -> statement .)
    DEDENT          reduce using rule 4 (statement_sequence -> statement .)
    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 34
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 12

    (10) compound_statement -> if_statement .

    ID              reduce using rule 10 (compound_statement -> if_statement .)
    RETURN          reduce using rule 10 (compound_statement -> if_statement .)
    IF              reduce using rule 10 (compound_statement -> if_statement .)
    WHILE           reduce using rule 10 (compound_statement -> if_statement .)
    DEFUN           reduce using rule 10 (compound_statement -> if_statement .)
    DEDENT          reduce using rule 10 (compound_statement -> if_statement .)
    ENDMARKER       reduce using rule 10 (compound_statement -> if_statement .)


state 13

    (7) simple_statement -> assignment . NEWLINE

    NEWLINE         shift and go to state 35


state 14

    (13) assignment -> ID . ASSIGN clause
    (14) assignment -> ID . INC expression
    (15) assignment -> ID . DEC expression
    (17) funcall -> ID . LPAREN args RPAREN
    (18) funcall -> ID . LPAREN RPAREN

    ASSIGN          shift and go to state 36
    INC             shift and go to state 39
    DEC             shift and go to state 38
    LPAREN          shift and go to state 37


state 15

    (21) if_statement -> IF . clause COLON suite if_closure
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 40
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 31

state 16

    (12) compound_statement -> fundef .

    ID              reduce using rule 12 (compound_statement -> fundef .)
    RETURN          reduce using rule 12 (compound_statement -> fundef .)
    IF              reduce using rule 12 (compound_statement -> fundef .)
    WHILE           reduce using rule 12 (compound_statement -> fundef .)
    DEFUN           reduce using rule 12 (compound_statement -> fundef .)
    DEDENT          reduce using rule 12 (compound_statement -> fundef .)
    ENDMARKER       reduce using rule 12 (compound_statement -> fundef .)


state 17

    (27) fundef -> DEFUN ID . LPAREN parameters RPAREN COLON suite

    LPAREN          shift and go to state 41


state 18

    (2) vyking_input -> statement_sequence ENDMARKER .

    $end            reduce using rule 2 (vyking_input -> statement_sequence ENDMARKER .)


state 19

    (9) simple_statement -> funcall NEWLINE .

    ID              reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    RETURN          reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    IF              reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    WHILE           reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    DEFUN           reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ENDMARKER       reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    DEDENT          reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ELSE            reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ELIF            reduce using rule 9 (simple_statement -> funcall NEWLINE .)


state 20

    (26) while_statement -> WHILE clause . COLON suite
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 42


state 21

    (49) expression -> numeric .

    PLUS            reduce using rule 49 (expression -> numeric .)
    MINUS           reduce using rule 49 (expression -> numeric .)
    TIMES           reduce using rule 49 (expression -> numeric .)
    DIVIDE          reduce using rule 49 (expression -> numeric .)
    MOD             reduce using rule 49 (expression -> numeric .)
    COLON           reduce using rule 49 (expression -> numeric .)
    OR              reduce using rule 49 (expression -> numeric .)
    AND             reduce using rule 49 (expression -> numeric .)
    RPAREN          reduce using rule 49 (expression -> numeric .)
    NEWLINE         reduce using rule 49 (expression -> numeric .)
    COMMA           reduce using rule 49 (expression -> numeric .)
    EQ              reduce using rule 49 (expression -> numeric .)
    NEQ             reduce using rule 49 (expression -> numeric .)
    LT              reduce using rule 49 (expression -> numeric .)
    GT              reduce using rule 49 (expression -> numeric .)
    GEQ             reduce using rule 49 (expression -> numeric .)
    LEQ             reduce using rule 49 (expression -> numeric .)


state 22

    (54) expression -> funcall .

    PLUS            reduce using rule 54 (expression -> funcall .)
    MINUS           reduce using rule 54 (expression -> funcall .)
    TIMES           reduce using rule 54 (expression -> funcall .)
    DIVIDE          reduce using rule 54 (expression -> funcall .)
    MOD             reduce using rule 54 (expression -> funcall .)
    COLON           reduce using rule 54 (expression -> funcall .)
    OR              reduce using rule 54 (expression -> funcall .)
    AND             reduce using rule 54 (expression -> funcall .)
    RPAREN          reduce using rule 54 (expression -> funcall .)
    NEWLINE         reduce using rule 54 (expression -> funcall .)
    COMMA           reduce using rule 54 (expression -> funcall .)
    EQ              reduce using rule 54 (expression -> funcall .)
    NEQ             reduce using rule 54 (expression -> funcall .)
    LT              reduce using rule 54 (expression -> funcall .)
    GT              reduce using rule 54 (expression -> funcall .)
    GEQ             reduce using rule 54 (expression -> funcall .)
    LEQ             reduce using rule 54 (expression -> funcall .)


state 23

    (48) expression -> MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 45
    numeric                        shift and go to state 21

state 24

    (53) expression -> STRING .

    PLUS            reduce using rule 53 (expression -> STRING .)
    MINUS           reduce using rule 53 (expression -> STRING .)
    TIMES           reduce using rule 53 (expression -> STRING .)
    DIVIDE          reduce using rule 53 (expression -> STRING .)
    MOD             reduce using rule 53 (expression -> STRING .)
    COLON           reduce using rule 53 (expression -> STRING .)
    OR              reduce using rule 53 (expression -> STRING .)
    AND             reduce using rule 53 (expression -> STRING .)
    RPAREN          reduce using rule 53 (expression -> STRING .)
    NEWLINE         reduce using rule 53 (expression -> STRING .)
    COMMA           reduce using rule 53 (expression -> STRING .)
    EQ              reduce using rule 53 (expression -> STRING .)
    NEQ             reduce using rule 53 (expression -> STRING .)
    LT              reduce using rule 53 (expression -> STRING .)
    GT              reduce using rule 53 (expression -> STRING .)
    GEQ             reduce using rule 53 (expression -> STRING .)
    LEQ             reduce using rule 53 (expression -> STRING .)


state 25

    (33) clause -> LPAREN . clause RPAREN
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 46
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 26

    (52) expression -> ID .
    (17) funcall -> ID . LPAREN args RPAREN
    (18) funcall -> ID . LPAREN RPAREN

    PLUS            reduce using rule 52 (expression -> ID .)
    MINUS           reduce using rule 52 (expression -> ID .)
    TIMES           reduce using rule 52 (expression -> ID .)
    DIVIDE          reduce using rule 52 (expression -> ID .)
    MOD             reduce using rule 52 (expression -> ID .)
    COLON           reduce using rule 52 (expression -> ID .)
    OR              reduce using rule 52 (expression -> ID .)
    AND             reduce using rule 52 (expression -> ID .)
    RPAREN          reduce using rule 52 (expression -> ID .)
    NEWLINE         reduce using rule 52 (expression -> ID .)
    COMMA           reduce using rule 52 (expression -> ID .)
    EQ              reduce using rule 52 (expression -> ID .)
    NEQ             reduce using rule 52 (expression -> ID .)
    LT              reduce using rule 52 (expression -> ID .)
    GT              reduce using rule 52 (expression -> ID .)
    GEQ             reduce using rule 52 (expression -> ID .)
    LEQ             reduce using rule 52 (expression -> ID .)
    LPAREN          shift and go to state 37


state 27

    (50) numeric -> INT .

    EQ              reduce using rule 50 (numeric -> INT .)
    NEQ             reduce using rule 50 (numeric -> INT .)
    LT              reduce using rule 50 (numeric -> INT .)
    GT              reduce using rule 50 (numeric -> INT .)
    GEQ             reduce using rule 50 (numeric -> INT .)
    LEQ             reduce using rule 50 (numeric -> INT .)
    PLUS            reduce using rule 50 (numeric -> INT .)
    MINUS           reduce using rule 50 (numeric -> INT .)
    TIMES           reduce using rule 50 (numeric -> INT .)
    DIVIDE          reduce using rule 50 (numeric -> INT .)
    MOD             reduce using rule 50 (numeric -> INT .)
    OR              reduce using rule 50 (numeric -> INT .)
    AND             reduce using rule 50 (numeric -> INT .)
    RPAREN          reduce using rule 50 (numeric -> INT .)
    COMMA           reduce using rule 50 (numeric -> INT .)
    COLON           reduce using rule 50 (numeric -> INT .)
    NEWLINE         reduce using rule 50 (numeric -> INT .)


state 28

    (51) numeric -> FLOAT .

    EQ              reduce using rule 51 (numeric -> FLOAT .)
    NEQ             reduce using rule 51 (numeric -> FLOAT .)
    LT              reduce using rule 51 (numeric -> FLOAT .)
    GT              reduce using rule 51 (numeric -> FLOAT .)
    GEQ             reduce using rule 51 (numeric -> FLOAT .)
    LEQ             reduce using rule 51 (numeric -> FLOAT .)
    PLUS            reduce using rule 51 (numeric -> FLOAT .)
    MINUS           reduce using rule 51 (numeric -> FLOAT .)
    TIMES           reduce using rule 51 (numeric -> FLOAT .)
    DIVIDE          reduce using rule 51 (numeric -> FLOAT .)
    MOD             reduce using rule 51 (numeric -> FLOAT .)
    OR              reduce using rule 51 (numeric -> FLOAT .)
    AND             reduce using rule 51 (numeric -> FLOAT .)
    RPAREN          reduce using rule 51 (numeric -> FLOAT .)
    COMMA           reduce using rule 51 (numeric -> FLOAT .)
    COLON           reduce using rule 51 (numeric -> FLOAT .)
    NEWLINE         reduce using rule 51 (numeric -> FLOAT .)


state 29

    (55) expression -> BOOLEAN .

    PLUS            reduce using rule 55 (expression -> BOOLEAN .)
    MINUS           reduce using rule 55 (expression -> BOOLEAN .)
    TIMES           reduce using rule 55 (expression -> BOOLEAN .)
    DIVIDE          reduce using rule 55 (expression -> BOOLEAN .)
    MOD             reduce using rule 55 (expression -> BOOLEAN .)
    COLON           reduce using rule 55 (expression -> BOOLEAN .)
    OR              reduce using rule 55 (expression -> BOOLEAN .)
    AND             reduce using rule 55 (expression -> BOOLEAN .)
    RPAREN          reduce using rule 55 (expression -> BOOLEAN .)
    NEWLINE         reduce using rule 55 (expression -> BOOLEAN .)
    COMMA           reduce using rule 55 (expression -> BOOLEAN .)
    EQ              reduce using rule 55 (expression -> BOOLEAN .)
    NEQ             reduce using rule 55 (expression -> BOOLEAN .)
    LT              reduce using rule 55 (expression -> BOOLEAN .)
    GT              reduce using rule 55 (expression -> BOOLEAN .)
    GEQ             reduce using rule 55 (expression -> BOOLEAN .)
    LEQ             reduce using rule 55 (expression -> BOOLEAN .)


state 30

    (32) clause -> NOT . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 47
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 31

    (36) clause -> expression . EQ expression
    (37) clause -> expression . NEQ expression
    (38) clause -> expression . LT expression
    (39) clause -> expression . GT expression
    (40) clause -> expression . GEQ expression
    (41) clause -> expression . LEQ expression
    (42) clause -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    EQ              shift and go to state 56
    NEQ             shift and go to state 58
    LT              shift and go to state 53
    GT              shift and go to state 49
    GEQ             shift and go to state 48
    LEQ             shift and go to state 52
    OR              reduce using rule 42 (clause -> expression .)
    AND             reduce using rule 42 (clause -> expression .)
    COLON           reduce using rule 42 (clause -> expression .)
    RPAREN          reduce using rule 42 (clause -> expression .)
    NEWLINE         reduce using rule 42 (clause -> expression .)
    COMMA           reduce using rule 42 (clause -> expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 32

    (16) return_statement -> RETURN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    NEWLINE         reduce using rule 16 (return_statement -> RETURN expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 33

    (8) simple_statement -> return_statement NEWLINE .

    ID              reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    RETURN          reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    IF              reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    WHILE           reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    DEFUN           reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ENDMARKER       reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    DEDENT          reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ELSE            reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ELIF            reduce using rule 8 (simple_statement -> return_statement NEWLINE .)


state 34

    (3) statement_sequence -> statement statement_sequence .

    ENDMARKER       reduce using rule 3 (statement_sequence -> statement statement_sequence .)
    DEDENT          reduce using rule 3 (statement_sequence -> statement statement_sequence .)


state 35

    (7) simple_statement -> assignment NEWLINE .

    ID              reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    RETURN          reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    IF              reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    WHILE           reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    DEFUN           reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ENDMARKER       reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    DEDENT          reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ELSE            reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ELIF            reduce using rule 7 (simple_statement -> assignment NEWLINE .)


state 36

    (13) assignment -> ID ASSIGN . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 59
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 37

    (17) funcall -> ID LPAREN . args RPAREN
    (18) funcall -> ID LPAREN . RPAREN
    (19) args -> . args COMMA clause
    (20) args -> . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 61
    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 60
    args                           shift and go to state 62
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 38

    (15) assignment -> ID DEC . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 63
    numeric                        shift and go to state 21

state 39

    (14) assignment -> ID INC . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 64
    numeric                        shift and go to state 21

state 40

    (21) if_statement -> IF clause . COLON suite if_closure
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 65
    OR              shift and go to state 44
    AND             shift and go to state 42


state 41

    (27) fundef -> DEFUN ID LPAREN . parameters RPAREN COLON suite
    (28) parameters -> . parameters COMMA ID
    (29) parameters -> . ID

    ID              shift and go to state 67

    parameters                     shift and go to state 66

state 42

    (35) clause -> clause AND . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 68
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 43

    (26) while_statement -> WHILE clause COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 69
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 70
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 71

state 44

    (34) clause -> clause OR . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 72
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 45

    (48) expression -> MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 48 (expression -> MINUS expression .)
    MINUS           reduce using rule 48 (expression -> MINUS expression .)
    TIMES           reduce using rule 48 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 48 (expression -> MINUS expression .)
    MOD             reduce using rule 48 (expression -> MINUS expression .)
    COLON           reduce using rule 48 (expression -> MINUS expression .)
    OR              reduce using rule 48 (expression -> MINUS expression .)
    AND             reduce using rule 48 (expression -> MINUS expression .)
    RPAREN          reduce using rule 48 (expression -> MINUS expression .)
    NEWLINE         reduce using rule 48 (expression -> MINUS expression .)
    COMMA           reduce using rule 48 (expression -> MINUS expression .)
    EQ              reduce using rule 48 (expression -> MINUS expression .)
    NEQ             reduce using rule 48 (expression -> MINUS expression .)
    LT              reduce using rule 48 (expression -> MINUS expression .)
    GT              reduce using rule 48 (expression -> MINUS expression .)
    GEQ             reduce using rule 48 (expression -> MINUS expression .)
    LEQ             reduce using rule 48 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 51 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! MOD             [ shift and go to state 55 ]


state 46

    (33) clause -> LPAREN clause . RPAREN
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          shift and go to state 73
    OR              shift and go to state 44
    AND             shift and go to state 42


state 47

    (32) clause -> NOT clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    OR              reduce using rule 32 (clause -> NOT clause .)
    AND             reduce using rule 32 (clause -> NOT clause .)
    COLON           reduce using rule 32 (clause -> NOT clause .)
    RPAREN          reduce using rule 32 (clause -> NOT clause .)
    NEWLINE         reduce using rule 32 (clause -> NOT clause .)
    COMMA           reduce using rule 32 (clause -> NOT clause .)

  ! OR              [ shift and go to state 44 ]
  ! AND             [ shift and go to state 42 ]


state 48

    (40) clause -> expression GEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 74
    numeric                        shift and go to state 21

state 49

    (39) clause -> expression GT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 75
    numeric                        shift and go to state 21

state 50

    (46) expression -> expression DIVIDE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 76
    numeric                        shift and go to state 21

state 51

    (45) expression -> expression TIMES . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 77
    numeric                        shift and go to state 21

state 52

    (41) clause -> expression LEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 78
    numeric                        shift and go to state 21

state 53

    (38) clause -> expression LT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 79
    numeric                        shift and go to state 21

state 54

    (43) expression -> expression PLUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 80
    numeric                        shift and go to state 21

state 55

    (47) expression -> expression MOD . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 81
    numeric                        shift and go to state 21

state 56

    (36) clause -> expression EQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 82
    numeric                        shift and go to state 21

state 57

    (44) expression -> expression MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 83
    numeric                        shift and go to state 21

state 58

    (37) clause -> expression NEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 84
    numeric                        shift and go to state 21

state 59

    (13) assignment -> ID ASSIGN clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    NEWLINE         reduce using rule 13 (assignment -> ID ASSIGN clause .)
    OR              shift and go to state 44
    AND             shift and go to state 42


state 60

    (20) args -> clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          reduce using rule 20 (args -> clause .)
    COMMA           reduce using rule 20 (args -> clause .)
    OR              shift and go to state 44
    AND             shift and go to state 42


state 61

    (18) funcall -> ID LPAREN RPAREN .

    PLUS            reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    MOD             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    COLON           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    OR              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    AND             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    NEWLINE         reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    EQ              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    LT              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    GT              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)


state 62

    (17) funcall -> ID LPAREN args . RPAREN
    (19) args -> args . COMMA clause

    RPAREN          shift and go to state 85
    COMMA           shift and go to state 86


state 63

    (15) assignment -> ID DEC expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    NEWLINE         reduce using rule 15 (assignment -> ID DEC expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 64

    (14) assignment -> ID INC expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    NEWLINE         reduce using rule 14 (assignment -> ID INC expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 65

    (21) if_statement -> IF clause COLON . suite if_closure
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 69
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 70
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 87

state 66

    (27) fundef -> DEFUN ID LPAREN parameters . RPAREN COLON suite
    (28) parameters -> parameters . COMMA ID

    RPAREN          shift and go to state 88
    COMMA           shift and go to state 89


state 67

    (29) parameters -> ID .

    RPAREN          reduce using rule 29 (parameters -> ID .)
    COMMA           reduce using rule 29 (parameters -> ID .)


state 68

    (35) clause -> clause AND clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    OR              reduce using rule 35 (clause -> clause AND clause .)
    AND             reduce using rule 35 (clause -> clause AND clause .)
    COLON           reduce using rule 35 (clause -> clause AND clause .)
    RPAREN          reduce using rule 35 (clause -> clause AND clause .)
    NEWLINE         reduce using rule 35 (clause -> clause AND clause .)
    COMMA           reduce using rule 35 (clause -> clause AND clause .)

  ! OR              [ shift and go to state 44 ]
  ! AND             [ shift and go to state 42 ]


state 69

    (31) suite -> NEWLINE . INDENT statement_sequence DEDENT

    INDENT          shift and go to state 90


state 70

    (30) suite -> simple_statement .

    ID              reduce using rule 30 (suite -> simple_statement .)
    RETURN          reduce using rule 30 (suite -> simple_statement .)
    IF              reduce using rule 30 (suite -> simple_statement .)
    WHILE           reduce using rule 30 (suite -> simple_statement .)
    DEFUN           reduce using rule 30 (suite -> simple_statement .)
    ENDMARKER       reduce using rule 30 (suite -> simple_statement .)
    DEDENT          reduce using rule 30 (suite -> simple_statement .)
    ELSE            reduce using rule 30 (suite -> simple_statement .)
    ELIF            reduce using rule 30 (suite -> simple_statement .)


state 71

    (26) while_statement -> WHILE clause COLON suite .

    ID              reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    RETURN          reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    IF              reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    WHILE           reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    DEFUN           reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    ENDMARKER       reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    DEDENT          reduce using rule 26 (while_statement -> WHILE clause COLON suite .)


state 72

    (34) clause -> clause OR clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    OR              reduce using rule 34 (clause -> clause OR clause .)
    AND             reduce using rule 34 (clause -> clause OR clause .)
    COLON           reduce using rule 34 (clause -> clause OR clause .)
    RPAREN          reduce using rule 34 (clause -> clause OR clause .)
    NEWLINE         reduce using rule 34 (clause -> clause OR clause .)
    COMMA           reduce using rule 34 (clause -> clause OR clause .)

  ! OR              [ shift and go to state 44 ]
  ! AND             [ shift and go to state 42 ]


state 73

    (33) clause -> LPAREN clause RPAREN .

    OR              reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    AND             reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    COLON           reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    RPAREN          reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    NEWLINE         reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    COMMA           reduce using rule 33 (clause -> LPAREN clause RPAREN .)


state 74

    (40) clause -> expression GEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 40 (clause -> expression GEQ expression .)
    AND             reduce using rule 40 (clause -> expression GEQ expression .)
    COLON           reduce using rule 40 (clause -> expression GEQ expression .)
    RPAREN          reduce using rule 40 (clause -> expression GEQ expression .)
    NEWLINE         reduce using rule 40 (clause -> expression GEQ expression .)
    COMMA           reduce using rule 40 (clause -> expression GEQ expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 75

    (39) clause -> expression GT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 39 (clause -> expression GT expression .)
    AND             reduce using rule 39 (clause -> expression GT expression .)
    COLON           reduce using rule 39 (clause -> expression GT expression .)
    RPAREN          reduce using rule 39 (clause -> expression GT expression .)
    NEWLINE         reduce using rule 39 (clause -> expression GT expression .)
    COMMA           reduce using rule 39 (clause -> expression GT expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 76

    (46) expression -> expression DIVIDE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 46 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 46 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 46 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 46 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 46 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 46 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 46 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 46 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 46 (expression -> expression DIVIDE expression .)
    NEWLINE         reduce using rule 46 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 46 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 46 (expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)
    LEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 51 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! MOD             [ shift and go to state 55 ]


state 77

    (45) expression -> expression TIMES expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 45 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 45 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 45 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 45 (expression -> expression TIMES expression .)
    MOD             reduce using rule 45 (expression -> expression TIMES expression .)
    COLON           reduce using rule 45 (expression -> expression TIMES expression .)
    OR              reduce using rule 45 (expression -> expression TIMES expression .)
    AND             reduce using rule 45 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 45 (expression -> expression TIMES expression .)
    NEWLINE         reduce using rule 45 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 45 (expression -> expression TIMES expression .)
    EQ              reduce using rule 45 (expression -> expression TIMES expression .)
    NEQ             reduce using rule 45 (expression -> expression TIMES expression .)
    LT              reduce using rule 45 (expression -> expression TIMES expression .)
    GT              reduce using rule 45 (expression -> expression TIMES expression .)
    GEQ             reduce using rule 45 (expression -> expression TIMES expression .)
    LEQ             reduce using rule 45 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 51 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! MOD             [ shift and go to state 55 ]


state 78

    (41) clause -> expression LEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 41 (clause -> expression LEQ expression .)
    AND             reduce using rule 41 (clause -> expression LEQ expression .)
    COLON           reduce using rule 41 (clause -> expression LEQ expression .)
    RPAREN          reduce using rule 41 (clause -> expression LEQ expression .)
    NEWLINE         reduce using rule 41 (clause -> expression LEQ expression .)
    COMMA           reduce using rule 41 (clause -> expression LEQ expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 79

    (38) clause -> expression LT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 38 (clause -> expression LT expression .)
    AND             reduce using rule 38 (clause -> expression LT expression .)
    COLON           reduce using rule 38 (clause -> expression LT expression .)
    RPAREN          reduce using rule 38 (clause -> expression LT expression .)
    NEWLINE         reduce using rule 38 (clause -> expression LT expression .)
    COMMA           reduce using rule 38 (clause -> expression LT expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 80

    (43) expression -> expression PLUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 43 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 43 (expression -> expression PLUS expression .)
    COLON           reduce using rule 43 (expression -> expression PLUS expression .)
    OR              reduce using rule 43 (expression -> expression PLUS expression .)
    AND             reduce using rule 43 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS expression .)
    NEWLINE         reduce using rule 43 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 43 (expression -> expression PLUS expression .)
    EQ              reduce using rule 43 (expression -> expression PLUS expression .)
    NEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    LT              reduce using rule 43 (expression -> expression PLUS expression .)
    GT              reduce using rule 43 (expression -> expression PLUS expression .)
    GEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    LEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55

  ! TIMES           [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]


state 81

    (47) expression -> expression MOD expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 47 (expression -> expression MOD expression .)
    MINUS           reduce using rule 47 (expression -> expression MOD expression .)
    TIMES           reduce using rule 47 (expression -> expression MOD expression .)
    DIVIDE          reduce using rule 47 (expression -> expression MOD expression .)
    MOD             reduce using rule 47 (expression -> expression MOD expression .)
    COLON           reduce using rule 47 (expression -> expression MOD expression .)
    OR              reduce using rule 47 (expression -> expression MOD expression .)
    AND             reduce using rule 47 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 47 (expression -> expression MOD expression .)
    NEWLINE         reduce using rule 47 (expression -> expression MOD expression .)
    COMMA           reduce using rule 47 (expression -> expression MOD expression .)
    EQ              reduce using rule 47 (expression -> expression MOD expression .)
    NEQ             reduce using rule 47 (expression -> expression MOD expression .)
    LT              reduce using rule 47 (expression -> expression MOD expression .)
    GT              reduce using rule 47 (expression -> expression MOD expression .)
    GEQ             reduce using rule 47 (expression -> expression MOD expression .)
    LEQ             reduce using rule 47 (expression -> expression MOD expression .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 51 ]
  ! DIVIDE          [ shift and go to state 50 ]
  ! MOD             [ shift and go to state 55 ]


state 82

    (36) clause -> expression EQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 36 (clause -> expression EQ expression .)
    AND             reduce using rule 36 (clause -> expression EQ expression .)
    COLON           reduce using rule 36 (clause -> expression EQ expression .)
    RPAREN          reduce using rule 36 (clause -> expression EQ expression .)
    NEWLINE         reduce using rule 36 (clause -> expression EQ expression .)
    COMMA           reduce using rule 36 (clause -> expression EQ expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 83

    (44) expression -> expression MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    PLUS            reduce using rule 44 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 44 (expression -> expression MINUS expression .)
    COLON           reduce using rule 44 (expression -> expression MINUS expression .)
    OR              reduce using rule 44 (expression -> expression MINUS expression .)
    AND             reduce using rule 44 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS expression .)
    NEWLINE         reduce using rule 44 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 44 (expression -> expression MINUS expression .)
    EQ              reduce using rule 44 (expression -> expression MINUS expression .)
    NEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    LT              reduce using rule 44 (expression -> expression MINUS expression .)
    GT              reduce using rule 44 (expression -> expression MINUS expression .)
    GEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    LEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55

  ! TIMES           [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 57 ]


state 84

    (37) clause -> expression NEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression

    OR              reduce using rule 37 (clause -> expression NEQ expression .)
    AND             reduce using rule 37 (clause -> expression NEQ expression .)
    COLON           reduce using rule 37 (clause -> expression NEQ expression .)
    RPAREN          reduce using rule 37 (clause -> expression NEQ expression .)
    NEWLINE         reduce using rule 37 (clause -> expression NEQ expression .)
    COMMA           reduce using rule 37 (clause -> expression NEQ expression .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 57
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 50
    MOD             shift and go to state 55


state 85

    (17) funcall -> ID LPAREN args RPAREN .

    PLUS            reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    TIMES           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    MOD             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    COLON           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    OR              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    AND             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    NEWLINE         reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    EQ              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    NEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    LT              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    GT              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    GEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    LEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)


state 86

    (19) args -> args COMMA . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 91
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 87

    (21) if_statement -> IF clause COLON suite . if_closure
    (22) if_closure -> . elif_statement
    (23) if_closure -> . ELSE COLON suite
    (24) if_closure -> . empty
    (25) elif_statement -> . ELIF clause COLON suite if_closure
    (1) empty -> .

    ELSE            shift and go to state 94
    ELIF            shift and go to state 92
    ID              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEFUN           reduce using rule 1 (empty -> .)
    ENDMARKER       reduce using rule 1 (empty -> .)
    DEDENT          reduce using rule 1 (empty -> .)

    elif_statement                 shift and go to state 93
    if_closure                     shift and go to state 95
    empty                          shift and go to state 96

state 88

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN . COLON suite

    COLON           shift and go to state 97


state 89

    (28) parameters -> parameters COMMA . ID

    ID              shift and go to state 98


state 90

    (31) suite -> NEWLINE INDENT . statement_sequence DEDENT
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 99
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 91

    (19) args -> args COMMA clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          reduce using rule 19 (args -> args COMMA clause .)
    COMMA           reduce using rule 19 (args -> args COMMA clause .)
    OR              shift and go to state 44
    AND             shift and go to state 42


state 92

    (25) elif_statement -> ELIF . clause COLON suite if_closure
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . MINUS expression
    (49) expression -> . numeric
    (52) expression -> . ID
    (53) expression -> . STRING
    (54) expression -> . funcall
    (55) expression -> . BOOLEAN
    (50) numeric -> . INT
    (51) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 30
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    BOOLEAN         shift and go to state 29
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 100
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 31

state 93

    (22) if_closure -> elif_statement .

    ID              reduce using rule 22 (if_closure -> elif_statement .)
    RETURN          reduce using rule 22 (if_closure -> elif_statement .)
    IF              reduce using rule 22 (if_closure -> elif_statement .)
    WHILE           reduce using rule 22 (if_closure -> elif_statement .)
    DEFUN           reduce using rule 22 (if_closure -> elif_statement .)
    ENDMARKER       reduce using rule 22 (if_closure -> elif_statement .)
    DEDENT          reduce using rule 22 (if_closure -> elif_statement .)


state 94

    (23) if_closure -> ELSE . COLON suite

    COLON           shift and go to state 101


state 95

    (21) if_statement -> IF clause COLON suite if_closure .

    ID              reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    RETURN          reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    IF              reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    WHILE           reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    DEFUN           reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    DEDENT          reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    ENDMARKER       reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)


state 96

    (24) if_closure -> empty .

    ID              reduce using rule 24 (if_closure -> empty .)
    RETURN          reduce using rule 24 (if_closure -> empty .)
    IF              reduce using rule 24 (if_closure -> empty .)
    WHILE           reduce using rule 24 (if_closure -> empty .)
    DEFUN           reduce using rule 24 (if_closure -> empty .)
    ENDMARKER       reduce using rule 24 (if_closure -> empty .)
    DEDENT          reduce using rule 24 (if_closure -> empty .)


state 97

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 69
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 70
    return_statement               shift and go to state 9
    suite                          shift and go to state 102

state 98

    (28) parameters -> parameters COMMA ID .

    RPAREN          reduce using rule 28 (parameters -> parameters COMMA ID .)
    COMMA           reduce using rule 28 (parameters -> parameters COMMA ID .)


state 99

    (31) suite -> NEWLINE INDENT statement_sequence . DEDENT

    DEDENT          shift and go to state 103


state 100

    (25) elif_statement -> ELIF clause . COLON suite if_closure
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 104
    OR              shift and go to state 44
    AND             shift and go to state 42


state 101

    (23) if_closure -> ELSE COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 69
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 70
    return_statement               shift and go to state 9
    suite                          shift and go to state 105

state 102

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .

    ID              reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    RETURN          reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    IF              reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    WHILE           reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    DEFUN           reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    ENDMARKER       reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    DEDENT          reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)


state 103

    (31) suite -> NEWLINE INDENT statement_sequence DEDENT .

    ID              reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    RETURN          reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    IF              reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    WHILE           reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    DEFUN           reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ENDMARKER       reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    DEDENT          reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ELSE            reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ELIF            reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)


state 104

    (25) elif_statement -> ELIF clause COLON . suite if_closure
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 69
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 70
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 106

state 105

    (23) if_closure -> ELSE COLON suite .

    ID              reduce using rule 23 (if_closure -> ELSE COLON suite .)
    RETURN          reduce using rule 23 (if_closure -> ELSE COLON suite .)
    IF              reduce using rule 23 (if_closure -> ELSE COLON suite .)
    WHILE           reduce using rule 23 (if_closure -> ELSE COLON suite .)
    DEFUN           reduce using rule 23 (if_closure -> ELSE COLON suite .)
    ENDMARKER       reduce using rule 23 (if_closure -> ELSE COLON suite .)
    DEDENT          reduce using rule 23 (if_closure -> ELSE COLON suite .)


state 106

    (25) elif_statement -> ELIF clause COLON suite . if_closure
    (22) if_closure -> . elif_statement
    (23) if_closure -> . ELSE COLON suite
    (24) if_closure -> . empty
    (25) elif_statement -> . ELIF clause COLON suite if_closure
    (1) empty -> .

    ELSE            shift and go to state 94
    ELIF            shift and go to state 92
    ID              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEFUN           reduce using rule 1 (empty -> .)
    ENDMARKER       reduce using rule 1 (empty -> .)
    DEDENT          reduce using rule 1 (empty -> .)

    elif_statement                 shift and go to state 93
    if_closure                     shift and go to state 107
    empty                          shift and go to state 96

state 107

    (25) elif_statement -> ELIF clause COLON suite if_closure .

    ID              reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    RETURN          reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    IF              reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    WHILE           reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    DEFUN           reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    ENDMARKER       reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    DEDENT          reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)

