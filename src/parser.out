Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> vyking_input
Rule 1     empty -> <empty>
Rule 2     vyking_input -> statement_sequence ENDMARKER
Rule 3     statement_sequence -> statement statement_sequence
Rule 4     statement_sequence -> statement
Rule 5     statement -> simple_statement
Rule 6     statement -> compound_statement
Rule 7     simple_statement -> assignment NEWLINE
Rule 8     simple_statement -> return_statement NEWLINE
Rule 9     simple_statement -> funcall NEWLINE
Rule 10    compound_statement -> if_statement
Rule 11    compound_statement -> while_statement
Rule 12    compound_statement -> fundef
Rule 13    assignment -> ID ASSIGN clause
Rule 14    assignment -> ID INC expression
Rule 15    assignment -> ID DEC expression
Rule 16    return_statement -> RETURN expression
Rule 17    funcall -> ID LPAREN args RPAREN
Rule 18    funcall -> ID LPAREN RPAREN
Rule 19    args -> args COMMA clause
Rule 20    args -> clause
Rule 21    if_statement -> IF clause COLON suite if_closure
Rule 22    if_closure -> elif_statement
Rule 23    if_closure -> ELSE COLON suite
Rule 24    if_closure -> empty
Rule 25    elif_statement -> ELIF clause COLON suite if_closure
Rule 26    while_statement -> WHILE clause COLON suite
Rule 27    fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite
Rule 28    parameters -> parameters COMMA ID
Rule 29    parameters -> ID
Rule 30    suite -> simple_statement
Rule 31    suite -> NEWLINE INDENT statement_sequence DEDENT
Rule 32    clause -> NOT clause
Rule 33    clause -> LPAREN clause RPAREN
Rule 34    clause -> clause OR clause
Rule 35    clause -> clause AND clause
Rule 36    clause -> expression EQ expression
Rule 37    clause -> expression NEQ expression
Rule 38    clause -> expression LT expression
Rule 39    clause -> expression GT expression
Rule 40    clause -> expression GEQ expression
Rule 41    clause -> expression LEQ expression
Rule 42    clause -> expression
Rule 43    expression -> expression PLUS expression
Rule 44    expression -> expression MINUS expression
Rule 45    expression -> expression TIMES expression
Rule 46    expression -> expression DIVIDE expression
Rule 47    expression -> MINUS expression
Rule 48    expression -> numeric
Rule 49    numeric -> INT
Rule 50    numeric -> FLOAT
Rule 51    expression -> ID
Rule 52    expression -> STRING
Rule 53    expression -> funcall

Terminals, with rules where they appear

AND                  : 35
ASSIGN               : 13
COLON                : 21 23 25 26 27
COMMA                : 19 28
DEC                  : 15
DEDENT               : 31
DEFUN                : 27
DIVIDE               : 46
ELIF                 : 25
ELSE                 : 23
ENDMARKER            : 2
EQ                   : 36
FLOAT                : 50
GEQ                  : 40
GT                   : 39
ID                   : 13 14 15 17 18 27 28 29 51
IF                   : 21
INC                  : 14
INDENT               : 31
INT                  : 49
LEQ                  : 41
LPAREN               : 17 18 27 33
LT                   : 38
MINUS                : 44 47
NEQ                  : 37
NEWLINE              : 7 8 9 31
NOT                  : 32
OR                   : 34
PLUS                 : 43
RETURN               : 16
RPAREN               : 17 18 27 33
STRING               : 52
TIMES                : 45
WHILE                : 26
error                : 

Nonterminals, with rules where they appear

args                 : 17 19
assignment           : 7
clause               : 13 19 20 21 25 26 32 33 34 34 35 35
compound_statement   : 6
elif_statement       : 22
empty                : 24
expression           : 14 15 16 36 36 37 37 38 38 39 39 40 40 41 41 42 43 43 44 44 45 45 46 46 47
funcall              : 9 53
fundef               : 12
if_closure           : 21 25
if_statement         : 10
numeric              : 48
parameters           : 27 28
return_statement     : 8
simple_statement     : 5 30
statement            : 3 4
statement_sequence   : 2 3 31
suite                : 21 23 25 26 27
vyking_input         : 0
while_statement      : 11

Parsing method: LALR

state 0

    (0) S' -> . vyking_input
    (2) vyking_input -> . statement_sequence ENDMARKER
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    vyking_input                   shift and go to state 1
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 4
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 1

    (0) S' -> vyking_input .



state 2

    (5) statement -> simple_statement .

    ID              reduce using rule 5 (statement -> simple_statement .)
    RETURN          reduce using rule 5 (statement -> simple_statement .)
    IF              reduce using rule 5 (statement -> simple_statement .)
    WHILE           reduce using rule 5 (statement -> simple_statement .)
    DEFUN           reduce using rule 5 (statement -> simple_statement .)
    ENDMARKER       reduce using rule 5 (statement -> simple_statement .)
    DEDENT          reduce using rule 5 (statement -> simple_statement .)


state 3

    (27) fundef -> DEFUN . ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 17


state 4

    (2) vyking_input -> statement_sequence . ENDMARKER

    ENDMARKER       shift and go to state 18


state 5

    (9) simple_statement -> funcall . NEWLINE

    NEWLINE         shift and go to state 19


state 6

    (26) while_statement -> WHILE . clause COLON suite
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 20
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 30

state 7

    (16) return_statement -> RETURN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 31
    numeric                        shift and go to state 21

state 8

    (6) statement -> compound_statement .

    ID              reduce using rule 6 (statement -> compound_statement .)
    RETURN          reduce using rule 6 (statement -> compound_statement .)
    IF              reduce using rule 6 (statement -> compound_statement .)
    WHILE           reduce using rule 6 (statement -> compound_statement .)
    DEFUN           reduce using rule 6 (statement -> compound_statement .)
    ENDMARKER       reduce using rule 6 (statement -> compound_statement .)
    DEDENT          reduce using rule 6 (statement -> compound_statement .)


state 9

    (8) simple_statement -> return_statement . NEWLINE

    NEWLINE         shift and go to state 32


state 10

    (11) compound_statement -> while_statement .

    ID              reduce using rule 11 (compound_statement -> while_statement .)
    RETURN          reduce using rule 11 (compound_statement -> while_statement .)
    IF              reduce using rule 11 (compound_statement -> while_statement .)
    WHILE           reduce using rule 11 (compound_statement -> while_statement .)
    DEFUN           reduce using rule 11 (compound_statement -> while_statement .)
    DEDENT          reduce using rule 11 (compound_statement -> while_statement .)
    ENDMARKER       reduce using rule 11 (compound_statement -> while_statement .)


state 11

    (3) statement_sequence -> statement . statement_sequence
    (4) statement_sequence -> statement .
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ENDMARKER       reduce using rule 4 (statement_sequence -> statement .)
    DEDENT          reduce using rule 4 (statement_sequence -> statement .)
    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 33
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 12

    (10) compound_statement -> if_statement .

    ID              reduce using rule 10 (compound_statement -> if_statement .)
    RETURN          reduce using rule 10 (compound_statement -> if_statement .)
    IF              reduce using rule 10 (compound_statement -> if_statement .)
    WHILE           reduce using rule 10 (compound_statement -> if_statement .)
    DEFUN           reduce using rule 10 (compound_statement -> if_statement .)
    DEDENT          reduce using rule 10 (compound_statement -> if_statement .)
    ENDMARKER       reduce using rule 10 (compound_statement -> if_statement .)


state 13

    (7) simple_statement -> assignment . NEWLINE

    NEWLINE         shift and go to state 34


state 14

    (13) assignment -> ID . ASSIGN clause
    (14) assignment -> ID . INC expression
    (15) assignment -> ID . DEC expression
    (17) funcall -> ID . LPAREN args RPAREN
    (18) funcall -> ID . LPAREN RPAREN

    ASSIGN          shift and go to state 35
    INC             shift and go to state 38
    DEC             shift and go to state 37
    LPAREN          shift and go to state 36


state 15

    (21) if_statement -> IF . clause COLON suite if_closure
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 39
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 30

state 16

    (12) compound_statement -> fundef .

    ID              reduce using rule 12 (compound_statement -> fundef .)
    RETURN          reduce using rule 12 (compound_statement -> fundef .)
    IF              reduce using rule 12 (compound_statement -> fundef .)
    WHILE           reduce using rule 12 (compound_statement -> fundef .)
    DEFUN           reduce using rule 12 (compound_statement -> fundef .)
    DEDENT          reduce using rule 12 (compound_statement -> fundef .)
    ENDMARKER       reduce using rule 12 (compound_statement -> fundef .)


state 17

    (27) fundef -> DEFUN ID . LPAREN parameters RPAREN COLON suite

    LPAREN          shift and go to state 40


state 18

    (2) vyking_input -> statement_sequence ENDMARKER .

    $end            reduce using rule 2 (vyking_input -> statement_sequence ENDMARKER .)


state 19

    (9) simple_statement -> funcall NEWLINE .

    ID              reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    RETURN          reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    IF              reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    WHILE           reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    DEFUN           reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ENDMARKER       reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    DEDENT          reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ELSE            reduce using rule 9 (simple_statement -> funcall NEWLINE .)
    ELIF            reduce using rule 9 (simple_statement -> funcall NEWLINE .)


state 20

    (26) while_statement -> WHILE clause . COLON suite
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 41


state 21

    (48) expression -> numeric .

    PLUS            reduce using rule 48 (expression -> numeric .)
    MINUS           reduce using rule 48 (expression -> numeric .)
    TIMES           reduce using rule 48 (expression -> numeric .)
    DIVIDE          reduce using rule 48 (expression -> numeric .)
    COLON           reduce using rule 48 (expression -> numeric .)
    OR              reduce using rule 48 (expression -> numeric .)
    AND             reduce using rule 48 (expression -> numeric .)
    RPAREN          reduce using rule 48 (expression -> numeric .)
    NEWLINE         reduce using rule 48 (expression -> numeric .)
    COMMA           reduce using rule 48 (expression -> numeric .)
    EQ              reduce using rule 48 (expression -> numeric .)
    NEQ             reduce using rule 48 (expression -> numeric .)
    LT              reduce using rule 48 (expression -> numeric .)
    GT              reduce using rule 48 (expression -> numeric .)
    GEQ             reduce using rule 48 (expression -> numeric .)
    LEQ             reduce using rule 48 (expression -> numeric .)


state 22

    (53) expression -> funcall .

    PLUS            reduce using rule 53 (expression -> funcall .)
    MINUS           reduce using rule 53 (expression -> funcall .)
    TIMES           reduce using rule 53 (expression -> funcall .)
    DIVIDE          reduce using rule 53 (expression -> funcall .)
    COLON           reduce using rule 53 (expression -> funcall .)
    OR              reduce using rule 53 (expression -> funcall .)
    AND             reduce using rule 53 (expression -> funcall .)
    RPAREN          reduce using rule 53 (expression -> funcall .)
    NEWLINE         reduce using rule 53 (expression -> funcall .)
    COMMA           reduce using rule 53 (expression -> funcall .)
    EQ              reduce using rule 53 (expression -> funcall .)
    NEQ             reduce using rule 53 (expression -> funcall .)
    LT              reduce using rule 53 (expression -> funcall .)
    GT              reduce using rule 53 (expression -> funcall .)
    GEQ             reduce using rule 53 (expression -> funcall .)
    LEQ             reduce using rule 53 (expression -> funcall .)


state 23

    (47) expression -> MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 44
    numeric                        shift and go to state 21

state 24

    (52) expression -> STRING .

    PLUS            reduce using rule 52 (expression -> STRING .)
    MINUS           reduce using rule 52 (expression -> STRING .)
    TIMES           reduce using rule 52 (expression -> STRING .)
    DIVIDE          reduce using rule 52 (expression -> STRING .)
    COLON           reduce using rule 52 (expression -> STRING .)
    OR              reduce using rule 52 (expression -> STRING .)
    AND             reduce using rule 52 (expression -> STRING .)
    RPAREN          reduce using rule 52 (expression -> STRING .)
    NEWLINE         reduce using rule 52 (expression -> STRING .)
    COMMA           reduce using rule 52 (expression -> STRING .)
    EQ              reduce using rule 52 (expression -> STRING .)
    NEQ             reduce using rule 52 (expression -> STRING .)
    LT              reduce using rule 52 (expression -> STRING .)
    GT              reduce using rule 52 (expression -> STRING .)
    GEQ             reduce using rule 52 (expression -> STRING .)
    LEQ             reduce using rule 52 (expression -> STRING .)


state 25

    (33) clause -> LPAREN . clause RPAREN
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 45
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 26

    (51) expression -> ID .
    (17) funcall -> ID . LPAREN args RPAREN
    (18) funcall -> ID . LPAREN RPAREN

    PLUS            reduce using rule 51 (expression -> ID .)
    MINUS           reduce using rule 51 (expression -> ID .)
    TIMES           reduce using rule 51 (expression -> ID .)
    DIVIDE          reduce using rule 51 (expression -> ID .)
    COLON           reduce using rule 51 (expression -> ID .)
    OR              reduce using rule 51 (expression -> ID .)
    AND             reduce using rule 51 (expression -> ID .)
    RPAREN          reduce using rule 51 (expression -> ID .)
    NEWLINE         reduce using rule 51 (expression -> ID .)
    COMMA           reduce using rule 51 (expression -> ID .)
    EQ              reduce using rule 51 (expression -> ID .)
    NEQ             reduce using rule 51 (expression -> ID .)
    LT              reduce using rule 51 (expression -> ID .)
    GT              reduce using rule 51 (expression -> ID .)
    GEQ             reduce using rule 51 (expression -> ID .)
    LEQ             reduce using rule 51 (expression -> ID .)
    LPAREN          shift and go to state 36


state 27

    (49) numeric -> INT .

    PLUS            reduce using rule 49 (numeric -> INT .)
    MINUS           reduce using rule 49 (numeric -> INT .)
    TIMES           reduce using rule 49 (numeric -> INT .)
    DIVIDE          reduce using rule 49 (numeric -> INT .)
    NEWLINE         reduce using rule 49 (numeric -> INT .)
    EQ              reduce using rule 49 (numeric -> INT .)
    NEQ             reduce using rule 49 (numeric -> INT .)
    LT              reduce using rule 49 (numeric -> INT .)
    GT              reduce using rule 49 (numeric -> INT .)
    GEQ             reduce using rule 49 (numeric -> INT .)
    LEQ             reduce using rule 49 (numeric -> INT .)
    OR              reduce using rule 49 (numeric -> INT .)
    AND             reduce using rule 49 (numeric -> INT .)
    RPAREN          reduce using rule 49 (numeric -> INT .)
    COMMA           reduce using rule 49 (numeric -> INT .)
    COLON           reduce using rule 49 (numeric -> INT .)


state 28

    (50) numeric -> FLOAT .

    PLUS            reduce using rule 50 (numeric -> FLOAT .)
    MINUS           reduce using rule 50 (numeric -> FLOAT .)
    TIMES           reduce using rule 50 (numeric -> FLOAT .)
    DIVIDE          reduce using rule 50 (numeric -> FLOAT .)
    NEWLINE         reduce using rule 50 (numeric -> FLOAT .)
    EQ              reduce using rule 50 (numeric -> FLOAT .)
    NEQ             reduce using rule 50 (numeric -> FLOAT .)
    LT              reduce using rule 50 (numeric -> FLOAT .)
    GT              reduce using rule 50 (numeric -> FLOAT .)
    GEQ             reduce using rule 50 (numeric -> FLOAT .)
    LEQ             reduce using rule 50 (numeric -> FLOAT .)
    OR              reduce using rule 50 (numeric -> FLOAT .)
    AND             reduce using rule 50 (numeric -> FLOAT .)
    RPAREN          reduce using rule 50 (numeric -> FLOAT .)
    COMMA           reduce using rule 50 (numeric -> FLOAT .)
    COLON           reduce using rule 50 (numeric -> FLOAT .)


state 29

    (32) clause -> NOT . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 46
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 30

    (36) clause -> expression . EQ expression
    (37) clause -> expression . NEQ expression
    (38) clause -> expression . LT expression
    (39) clause -> expression . GT expression
    (40) clause -> expression . GEQ expression
    (41) clause -> expression . LEQ expression
    (42) clause -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    EQ              shift and go to state 54
    NEQ             shift and go to state 56
    LT              shift and go to state 52
    GT              shift and go to state 48
    GEQ             shift and go to state 47
    LEQ             shift and go to state 51
    COLON           reduce using rule 42 (clause -> expression .)
    OR              reduce using rule 42 (clause -> expression .)
    AND             reduce using rule 42 (clause -> expression .)
    RPAREN          reduce using rule 42 (clause -> expression .)
    NEWLINE         reduce using rule 42 (clause -> expression .)
    COMMA           reduce using rule 42 (clause -> expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 31

    (16) return_statement -> RETURN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    NEWLINE         reduce using rule 16 (return_statement -> RETURN expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 32

    (8) simple_statement -> return_statement NEWLINE .

    ID              reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    RETURN          reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    IF              reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    WHILE           reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    DEFUN           reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ENDMARKER       reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    DEDENT          reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ELSE            reduce using rule 8 (simple_statement -> return_statement NEWLINE .)
    ELIF            reduce using rule 8 (simple_statement -> return_statement NEWLINE .)


state 33

    (3) statement_sequence -> statement statement_sequence .

    ENDMARKER       reduce using rule 3 (statement_sequence -> statement statement_sequence .)
    DEDENT          reduce using rule 3 (statement_sequence -> statement statement_sequence .)


state 34

    (7) simple_statement -> assignment NEWLINE .

    ID              reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    RETURN          reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    IF              reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    WHILE           reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    DEFUN           reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ENDMARKER       reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    DEDENT          reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ELSE            reduce using rule 7 (simple_statement -> assignment NEWLINE .)
    ELIF            reduce using rule 7 (simple_statement -> assignment NEWLINE .)


state 35

    (13) assignment -> ID ASSIGN . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 57
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 36

    (17) funcall -> ID LPAREN . args RPAREN
    (18) funcall -> ID LPAREN . RPAREN
    (19) args -> . args COMMA clause
    (20) args -> . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 59
    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 58
    args                           shift and go to state 60
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 37

    (15) assignment -> ID DEC . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 61
    numeric                        shift and go to state 21

state 38

    (14) assignment -> ID INC . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 62
    numeric                        shift and go to state 21

state 39

    (21) if_statement -> IF clause . COLON suite if_closure
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 63
    OR              shift and go to state 43
    AND             shift and go to state 41


state 40

    (27) fundef -> DEFUN ID LPAREN . parameters RPAREN COLON suite
    (28) parameters -> . parameters COMMA ID
    (29) parameters -> . ID

    ID              shift and go to state 65

    parameters                     shift and go to state 64

state 41

    (35) clause -> clause AND . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 66
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 42

    (26) while_statement -> WHILE clause COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 67
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 68
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 69

state 43

    (34) clause -> clause OR . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 70
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 44

    (47) expression -> MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 47 (expression -> MINUS expression .)
    MINUS           reduce using rule 47 (expression -> MINUS expression .)
    TIMES           reduce using rule 47 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 47 (expression -> MINUS expression .)
    COLON           reduce using rule 47 (expression -> MINUS expression .)
    OR              reduce using rule 47 (expression -> MINUS expression .)
    AND             reduce using rule 47 (expression -> MINUS expression .)
    RPAREN          reduce using rule 47 (expression -> MINUS expression .)
    NEWLINE         reduce using rule 47 (expression -> MINUS expression .)
    COMMA           reduce using rule 47 (expression -> MINUS expression .)
    EQ              reduce using rule 47 (expression -> MINUS expression .)
    NEQ             reduce using rule 47 (expression -> MINUS expression .)
    LT              reduce using rule 47 (expression -> MINUS expression .)
    GT              reduce using rule 47 (expression -> MINUS expression .)
    GEQ             reduce using rule 47 (expression -> MINUS expression .)
    LEQ             reduce using rule 47 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 53 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 50 ]
  ! DIVIDE          [ shift and go to state 49 ]


state 45

    (33) clause -> LPAREN clause . RPAREN
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          shift and go to state 71
    OR              shift and go to state 43
    AND             shift and go to state 41


state 46

    (32) clause -> NOT clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           reduce using rule 32 (clause -> NOT clause .)
    OR              reduce using rule 32 (clause -> NOT clause .)
    AND             reduce using rule 32 (clause -> NOT clause .)
    RPAREN          reduce using rule 32 (clause -> NOT clause .)
    NEWLINE         reduce using rule 32 (clause -> NOT clause .)
    COMMA           reduce using rule 32 (clause -> NOT clause .)

  ! OR              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 41 ]


state 47

    (40) clause -> expression GEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 72
    numeric                        shift and go to state 21

state 48

    (39) clause -> expression GT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 73
    numeric                        shift and go to state 21

state 49

    (46) expression -> expression DIVIDE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 74
    numeric                        shift and go to state 21

state 50

    (45) expression -> expression TIMES . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 75
    numeric                        shift and go to state 21

state 51

    (41) clause -> expression LEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 76
    numeric                        shift and go to state 21

state 52

    (38) clause -> expression LT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 77
    numeric                        shift and go to state 21

state 53

    (43) expression -> expression PLUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 78
    numeric                        shift and go to state 21

state 54

    (36) clause -> expression EQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 79
    numeric                        shift and go to state 21

state 55

    (44) expression -> expression MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 80
    numeric                        shift and go to state 21

state 56

    (37) clause -> expression NEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    expression                     shift and go to state 81
    numeric                        shift and go to state 21

state 57

    (13) assignment -> ID ASSIGN clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    NEWLINE         reduce using rule 13 (assignment -> ID ASSIGN clause .)
    OR              shift and go to state 43
    AND             shift and go to state 41


state 58

    (20) args -> clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          reduce using rule 20 (args -> clause .)
    COMMA           reduce using rule 20 (args -> clause .)
    OR              shift and go to state 43
    AND             shift and go to state 41


state 59

    (18) funcall -> ID LPAREN RPAREN .

    NEWLINE         reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    EQ              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    NEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    LT              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    GT              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    GEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    LEQ             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    COLON           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    OR              reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    AND             reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 18 (funcall -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 18 (funcall -> ID LPAREN RPAREN .)


state 60

    (17) funcall -> ID LPAREN args . RPAREN
    (19) args -> args . COMMA clause

    RPAREN          shift and go to state 82
    COMMA           shift and go to state 83


state 61

    (15) assignment -> ID DEC expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    NEWLINE         reduce using rule 15 (assignment -> ID DEC expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 62

    (14) assignment -> ID INC expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    NEWLINE         reduce using rule 14 (assignment -> ID INC expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 63

    (21) if_statement -> IF clause COLON . suite if_closure
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 67
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 68
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 84

state 64

    (27) fundef -> DEFUN ID LPAREN parameters . RPAREN COLON suite
    (28) parameters -> parameters . COMMA ID

    RPAREN          shift and go to state 85
    COMMA           shift and go to state 86


state 65

    (29) parameters -> ID .

    RPAREN          reduce using rule 29 (parameters -> ID .)
    COMMA           reduce using rule 29 (parameters -> ID .)


state 66

    (35) clause -> clause AND clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           reduce using rule 35 (clause -> clause AND clause .)
    OR              reduce using rule 35 (clause -> clause AND clause .)
    AND             reduce using rule 35 (clause -> clause AND clause .)
    RPAREN          reduce using rule 35 (clause -> clause AND clause .)
    NEWLINE         reduce using rule 35 (clause -> clause AND clause .)
    COMMA           reduce using rule 35 (clause -> clause AND clause .)

  ! OR              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 41 ]


state 67

    (31) suite -> NEWLINE . INDENT statement_sequence DEDENT

    INDENT          shift and go to state 87


state 68

    (30) suite -> simple_statement .

    ID              reduce using rule 30 (suite -> simple_statement .)
    RETURN          reduce using rule 30 (suite -> simple_statement .)
    IF              reduce using rule 30 (suite -> simple_statement .)
    WHILE           reduce using rule 30 (suite -> simple_statement .)
    DEFUN           reduce using rule 30 (suite -> simple_statement .)
    ENDMARKER       reduce using rule 30 (suite -> simple_statement .)
    DEDENT          reduce using rule 30 (suite -> simple_statement .)
    ELSE            reduce using rule 30 (suite -> simple_statement .)
    ELIF            reduce using rule 30 (suite -> simple_statement .)


state 69

    (26) while_statement -> WHILE clause COLON suite .

    ID              reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    RETURN          reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    IF              reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    WHILE           reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    DEFUN           reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    DEDENT          reduce using rule 26 (while_statement -> WHILE clause COLON suite .)
    ENDMARKER       reduce using rule 26 (while_statement -> WHILE clause COLON suite .)


state 70

    (34) clause -> clause OR clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           reduce using rule 34 (clause -> clause OR clause .)
    OR              reduce using rule 34 (clause -> clause OR clause .)
    AND             reduce using rule 34 (clause -> clause OR clause .)
    RPAREN          reduce using rule 34 (clause -> clause OR clause .)
    NEWLINE         reduce using rule 34 (clause -> clause OR clause .)
    COMMA           reduce using rule 34 (clause -> clause OR clause .)

  ! OR              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 41 ]


state 71

    (33) clause -> LPAREN clause RPAREN .

    COLON           reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    OR              reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    AND             reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    RPAREN          reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    NEWLINE         reduce using rule 33 (clause -> LPAREN clause RPAREN .)
    COMMA           reduce using rule 33 (clause -> LPAREN clause RPAREN .)


state 72

    (40) clause -> expression GEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 40 (clause -> expression GEQ expression .)
    OR              reduce using rule 40 (clause -> expression GEQ expression .)
    AND             reduce using rule 40 (clause -> expression GEQ expression .)
    RPAREN          reduce using rule 40 (clause -> expression GEQ expression .)
    NEWLINE         reduce using rule 40 (clause -> expression GEQ expression .)
    COMMA           reduce using rule 40 (clause -> expression GEQ expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 73

    (39) clause -> expression GT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 39 (clause -> expression GT expression .)
    OR              reduce using rule 39 (clause -> expression GT expression .)
    AND             reduce using rule 39 (clause -> expression GT expression .)
    RPAREN          reduce using rule 39 (clause -> expression GT expression .)
    NEWLINE         reduce using rule 39 (clause -> expression GT expression .)
    COMMA           reduce using rule 39 (clause -> expression GT expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 74

    (46) expression -> expression DIVIDE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 46 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 46 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 46 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 46 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 46 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 46 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 46 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 46 (expression -> expression DIVIDE expression .)
    NEWLINE         reduce using rule 46 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 46 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 46 (expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)
    LEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 53 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 50 ]
  ! DIVIDE          [ shift and go to state 49 ]


state 75

    (45) expression -> expression TIMES expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 45 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 45 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 45 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 45 (expression -> expression TIMES expression .)
    COLON           reduce using rule 45 (expression -> expression TIMES expression .)
    OR              reduce using rule 45 (expression -> expression TIMES expression .)
    AND             reduce using rule 45 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 45 (expression -> expression TIMES expression .)
    NEWLINE         reduce using rule 45 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 45 (expression -> expression TIMES expression .)
    EQ              reduce using rule 45 (expression -> expression TIMES expression .)
    NEQ             reduce using rule 45 (expression -> expression TIMES expression .)
    LT              reduce using rule 45 (expression -> expression TIMES expression .)
    GT              reduce using rule 45 (expression -> expression TIMES expression .)
    GEQ             reduce using rule 45 (expression -> expression TIMES expression .)
    LEQ             reduce using rule 45 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 53 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 50 ]
  ! DIVIDE          [ shift and go to state 49 ]


state 76

    (41) clause -> expression LEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 41 (clause -> expression LEQ expression .)
    OR              reduce using rule 41 (clause -> expression LEQ expression .)
    AND             reduce using rule 41 (clause -> expression LEQ expression .)
    RPAREN          reduce using rule 41 (clause -> expression LEQ expression .)
    NEWLINE         reduce using rule 41 (clause -> expression LEQ expression .)
    COMMA           reduce using rule 41 (clause -> expression LEQ expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 77

    (38) clause -> expression LT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 38 (clause -> expression LT expression .)
    OR              reduce using rule 38 (clause -> expression LT expression .)
    AND             reduce using rule 38 (clause -> expression LT expression .)
    RPAREN          reduce using rule 38 (clause -> expression LT expression .)
    NEWLINE         reduce using rule 38 (clause -> expression LT expression .)
    COMMA           reduce using rule 38 (clause -> expression LT expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 78

    (43) expression -> expression PLUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 43 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 43 (expression -> expression PLUS expression .)
    COLON           reduce using rule 43 (expression -> expression PLUS expression .)
    OR              reduce using rule 43 (expression -> expression PLUS expression .)
    AND             reduce using rule 43 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS expression .)
    NEWLINE         reduce using rule 43 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 43 (expression -> expression PLUS expression .)
    EQ              reduce using rule 43 (expression -> expression PLUS expression .)
    NEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    LT              reduce using rule 43 (expression -> expression PLUS expression .)
    GT              reduce using rule 43 (expression -> expression PLUS expression .)
    GEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    LEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49

  ! TIMES           [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 53 ]
  ! MINUS           [ shift and go to state 55 ]


state 79

    (36) clause -> expression EQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 36 (clause -> expression EQ expression .)
    OR              reduce using rule 36 (clause -> expression EQ expression .)
    AND             reduce using rule 36 (clause -> expression EQ expression .)
    RPAREN          reduce using rule 36 (clause -> expression EQ expression .)
    NEWLINE         reduce using rule 36 (clause -> expression EQ expression .)
    COMMA           reduce using rule 36 (clause -> expression EQ expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 80

    (44) expression -> expression MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 44 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 44 (expression -> expression MINUS expression .)
    COLON           reduce using rule 44 (expression -> expression MINUS expression .)
    OR              reduce using rule 44 (expression -> expression MINUS expression .)
    AND             reduce using rule 44 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS expression .)
    NEWLINE         reduce using rule 44 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 44 (expression -> expression MINUS expression .)
    EQ              reduce using rule 44 (expression -> expression MINUS expression .)
    NEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    LT              reduce using rule 44 (expression -> expression MINUS expression .)
    GT              reduce using rule 44 (expression -> expression MINUS expression .)
    GEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    LEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49

  ! TIMES           [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 53 ]
  ! MINUS           [ shift and go to state 55 ]


state 81

    (37) clause -> expression NEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression

    COLON           reduce using rule 37 (clause -> expression NEQ expression .)
    OR              reduce using rule 37 (clause -> expression NEQ expression .)
    AND             reduce using rule 37 (clause -> expression NEQ expression .)
    RPAREN          reduce using rule 37 (clause -> expression NEQ expression .)
    NEWLINE         reduce using rule 37 (clause -> expression NEQ expression .)
    COMMA           reduce using rule 37 (clause -> expression NEQ expression .)
    PLUS            shift and go to state 53
    MINUS           shift and go to state 55
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 49


state 82

    (17) funcall -> ID LPAREN args RPAREN .

    NEWLINE         reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    EQ              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    NEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    LT              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    GT              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    GEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    LEQ             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    TIMES           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    COLON           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    OR              reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    AND             reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 17 (funcall -> ID LPAREN args RPAREN .)


state 83

    (19) args -> args COMMA . clause
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    funcall                        shift and go to state 22
    clause                         shift and go to state 88
    expression                     shift and go to state 30
    numeric                        shift and go to state 21

state 84

    (21) if_statement -> IF clause COLON suite . if_closure
    (22) if_closure -> . elif_statement
    (23) if_closure -> . ELSE COLON suite
    (24) if_closure -> . empty
    (25) elif_statement -> . ELIF clause COLON suite if_closure
    (1) empty -> .

    ELSE            shift and go to state 91
    ELIF            shift and go to state 89
    ID              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEFUN           reduce using rule 1 (empty -> .)
    ENDMARKER       reduce using rule 1 (empty -> .)
    DEDENT          reduce using rule 1 (empty -> .)

    elif_statement                 shift and go to state 90
    if_closure                     shift and go to state 92
    empty                          shift and go to state 93

state 85

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN . COLON suite

    COLON           shift and go to state 94


state 86

    (28) parameters -> parameters COMMA . ID

    ID              shift and go to state 95


state 87

    (31) suite -> NEWLINE INDENT . statement_sequence DEDENT
    (3) statement_sequence -> . statement statement_sequence
    (4) statement_sequence -> . statement
    (5) statement -> . simple_statement
    (6) statement -> . compound_statement
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (10) compound_statement -> . if_statement
    (11) compound_statement -> . while_statement
    (12) compound_statement -> . fundef
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN
    (21) if_statement -> . IF clause COLON suite if_closure
    (26) while_statement -> . WHILE clause COLON suite
    (27) fundef -> . DEFUN ID LPAREN parameters RPAREN COLON suite

    ID              shift and go to state 14
    RETURN          shift and go to state 7
    IF              shift and go to state 15
    WHILE           shift and go to state 6
    DEFUN           shift and go to state 3

    funcall                        shift and go to state 5
    compound_statement             shift and go to state 8
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 2
    fundef                         shift and go to state 16
    statement_sequence             shift and go to state 96
    return_statement               shift and go to state 9
    while_statement                shift and go to state 10
    statement                      shift and go to state 11
    if_statement                   shift and go to state 12

state 88

    (19) args -> args COMMA clause .
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    RPAREN          reduce using rule 19 (args -> args COMMA clause .)
    COMMA           reduce using rule 19 (args -> args COMMA clause .)
    OR              shift and go to state 43
    AND             shift and go to state 41


state 89

    (25) elif_statement -> ELIF . clause COLON suite if_closure
    (32) clause -> . NOT clause
    (33) clause -> . LPAREN clause RPAREN
    (34) clause -> . clause OR clause
    (35) clause -> . clause AND clause
    (36) clause -> . expression EQ expression
    (37) clause -> . expression NEQ expression
    (38) clause -> . expression LT expression
    (39) clause -> . expression GT expression
    (40) clause -> . expression GEQ expression
    (41) clause -> . expression LEQ expression
    (42) clause -> . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . MINUS expression
    (48) expression -> . numeric
    (51) expression -> . ID
    (52) expression -> . STRING
    (53) expression -> . funcall
    (49) numeric -> . INT
    (50) numeric -> . FLOAT
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NOT             shift and go to state 29
    LPAREN          shift and go to state 25
    MINUS           shift and go to state 23
    ID              shift and go to state 26
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 28

    clause                         shift and go to state 97
    numeric                        shift and go to state 21
    funcall                        shift and go to state 22
    expression                     shift and go to state 30

state 90

    (22) if_closure -> elif_statement .

    ID              reduce using rule 22 (if_closure -> elif_statement .)
    RETURN          reduce using rule 22 (if_closure -> elif_statement .)
    IF              reduce using rule 22 (if_closure -> elif_statement .)
    WHILE           reduce using rule 22 (if_closure -> elif_statement .)
    DEFUN           reduce using rule 22 (if_closure -> elif_statement .)
    ENDMARKER       reduce using rule 22 (if_closure -> elif_statement .)
    DEDENT          reduce using rule 22 (if_closure -> elif_statement .)


state 91

    (23) if_closure -> ELSE . COLON suite

    COLON           shift and go to state 98


state 92

    (21) if_statement -> IF clause COLON suite if_closure .

    ID              reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    RETURN          reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    IF              reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    WHILE           reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    DEFUN           reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    ENDMARKER       reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)
    DEDENT          reduce using rule 21 (if_statement -> IF clause COLON suite if_closure .)


state 93

    (24) if_closure -> empty .

    ID              reduce using rule 24 (if_closure -> empty .)
    RETURN          reduce using rule 24 (if_closure -> empty .)
    IF              reduce using rule 24 (if_closure -> empty .)
    WHILE           reduce using rule 24 (if_closure -> empty .)
    DEFUN           reduce using rule 24 (if_closure -> empty .)
    ENDMARKER       reduce using rule 24 (if_closure -> empty .)
    DEDENT          reduce using rule 24 (if_closure -> empty .)


state 94

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 67
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 68
    return_statement               shift and go to state 9
    suite                          shift and go to state 99

state 95

    (28) parameters -> parameters COMMA ID .

    RPAREN          reduce using rule 28 (parameters -> parameters COMMA ID .)
    COMMA           reduce using rule 28 (parameters -> parameters COMMA ID .)


state 96

    (31) suite -> NEWLINE INDENT statement_sequence . DEDENT

    DEDENT          shift and go to state 100


state 97

    (25) elif_statement -> ELIF clause . COLON suite if_closure
    (34) clause -> clause . OR clause
    (35) clause -> clause . AND clause

    COLON           shift and go to state 101
    OR              shift and go to state 43
    AND             shift and go to state 41


state 98

    (23) if_closure -> ELSE COLON . suite
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 67
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    assignment                     shift and go to state 13
    simple_statement               shift and go to state 68
    return_statement               shift and go to state 9
    suite                          shift and go to state 102

state 99

    (27) fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .

    ID              reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    RETURN          reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    IF              reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    WHILE           reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    DEFUN           reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    ENDMARKER       reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)
    DEDENT          reduce using rule 27 (fundef -> DEFUN ID LPAREN parameters RPAREN COLON suite .)


state 100

    (31) suite -> NEWLINE INDENT statement_sequence DEDENT .

    ID              reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    RETURN          reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    IF              reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    WHILE           reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    DEFUN           reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ENDMARKER       reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    DEDENT          reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ELSE            reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)
    ELIF            reduce using rule 31 (suite -> NEWLINE INDENT statement_sequence DEDENT .)


state 101

    (25) elif_statement -> ELIF clause COLON . suite if_closure
    (30) suite -> . simple_statement
    (31) suite -> . NEWLINE INDENT statement_sequence DEDENT
    (7) simple_statement -> . assignment NEWLINE
    (8) simple_statement -> . return_statement NEWLINE
    (9) simple_statement -> . funcall NEWLINE
    (13) assignment -> . ID ASSIGN clause
    (14) assignment -> . ID INC expression
    (15) assignment -> . ID DEC expression
    (16) return_statement -> . RETURN expression
    (17) funcall -> . ID LPAREN args RPAREN
    (18) funcall -> . ID LPAREN RPAREN

    NEWLINE         shift and go to state 67
    ID              shift and go to state 14
    RETURN          shift and go to state 7

    funcall                        shift and go to state 5
    simple_statement               shift and go to state 68
    return_statement               shift and go to state 9
    assignment                     shift and go to state 13
    suite                          shift and go to state 103

state 102

    (23) if_closure -> ELSE COLON suite .

    ID              reduce using rule 23 (if_closure -> ELSE COLON suite .)
    RETURN          reduce using rule 23 (if_closure -> ELSE COLON suite .)
    IF              reduce using rule 23 (if_closure -> ELSE COLON suite .)
    WHILE           reduce using rule 23 (if_closure -> ELSE COLON suite .)
    DEFUN           reduce using rule 23 (if_closure -> ELSE COLON suite .)
    ENDMARKER       reduce using rule 23 (if_closure -> ELSE COLON suite .)
    DEDENT          reduce using rule 23 (if_closure -> ELSE COLON suite .)


state 103

    (25) elif_statement -> ELIF clause COLON suite . if_closure
    (22) if_closure -> . elif_statement
    (23) if_closure -> . ELSE COLON suite
    (24) if_closure -> . empty
    (25) elif_statement -> . ELIF clause COLON suite if_closure
    (1) empty -> .

    ELSE            shift and go to state 91
    ELIF            shift and go to state 89
    ID              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEFUN           reduce using rule 1 (empty -> .)
    ENDMARKER       reduce using rule 1 (empty -> .)
    DEDENT          reduce using rule 1 (empty -> .)

    elif_statement                 shift and go to state 90
    if_closure                     shift and go to state 104
    empty                          shift and go to state 93

state 104

    (25) elif_statement -> ELIF clause COLON suite if_closure .

    ID              reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    RETURN          reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    IF              reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    WHILE           reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    DEFUN           reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    ENDMARKER       reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)
    DEDENT          reduce using rule 25 (elif_statement -> ELIF clause COLON suite if_closure .)

