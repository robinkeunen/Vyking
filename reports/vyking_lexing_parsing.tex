% !TEX encoding = UTF-8
\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}


%math 
\usepackage{amsmath}
%\usepackage{amssymb} // Decommenter si le dernier n'est pas suffisant

%Chimie
\usepackage[version=3]{mhchem}
%cf http://fr.wikibooks.org/wiki/LaTeX/%C3%89crire_des_formules_chimiques

% Allows for temporary adjustment of side margins
% Lorsque les tableaux sont trop grands
\usepackage{chngpage}
 \usepackage{multirow} 
 
% provides filler text
\usepackage{lipsum}
% usage : \lipsum[1]

% just makes the table prettier (see \toprule, \bottomrule, etc. commands below)
\usepackage{booktabs}

%Mise en page
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[top=3cm, bottom=3cm, left=4cm, right=3cm]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{placeins}

\definecolor{gris}{gray}{0.5}
\definecolor{code}{gray}{0.95}

% Table des matières cliquable 
\usepackage{hyperref}
\hypersetup{
    colorlinks, % empécher latex de colorer les liens
    citecolor=black,
    filecolor=black,
    linkcolor=black, % couleur des liens dans la table des matières
    urlcolor=blue
}

%Points dans la table des matières
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % Ligne de points dans la table des matières


%Page de garde

\newlength{\larg}
\setlength{\larg}{14.5cm}

% Pour corriger alignement, jouer avec la taille de tabular (± 6cm)
\title{
{\rule{\larg}{1mm}}\vspace{7mm}
\begin{tabular}{p{7,6cm} r}
 \multirow{3}{*}{\includegraphics[width=70px]{vyking-logo2.jpg}} & {\Huge {\bf Langage Vyking}} \\
   & \\
   & {\Large Lexing et parsing}
\end{tabular}\\
\vspace{2mm}
{\rule{\larg}{1mm}}
\vspace{2mm} \\
\begin{tabular}{p{9.8cm} r}
   & {\large \bf Compilateurs} \\
   & {\large \bf INFO0085} \\
   & {\large \bf \bsc{Pr. Pierre Geurts}}\\
   & {\large \bf \bsc{Cyril Soldani}}\\
   & {\large  \today}
\end{tabular}\\
\vspace{10cm}
}
\author{\begin{tabular}{p{13.7cm}}
\bsc{Robin Keunen} s093137\\
\bsc{Pierre Vyncke} s091918\\
1\up{ère} Master Ingénieur Civil
\end{tabular}\\
\hline }
\date{}

\usepackage{times}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}

\definecolor{quotationcolour}{HTML}{F0F0F0}
\definecolor{quotationmarkcolour}{HTML}{1F3F81}

% Double-line for start and end of epigraph.
\newcommand{\epiline}{\hrule \vskip -.2em \hrule}
% Massively humongous opening quotation mark.
\newcommand{\hugequote}{%
  \fontsize{42}{48}\selectfont \color{quotationmarkcolour} \textbf{``}
  \vskip -.5em
}

% Beautify quotations.
\newcommand{\epigraph}[2]{%
  \bigskip
  \begin{flushright}
  \colorbox{quotationcolour}{%
    \parbox{.60\textwidth}{%
    \epiline \vskip 1em {\hugequote} \vskip -.5em
    \parindent 2.2em
    #1\begin{flushright}\textsc{#2}\end{flushright}
    \epiline
    }
  }
  \end{flushright}
  \bigskip
}

\begin{document}

% Titre
\maketitle
\thispagestyle{empty}
\newpage

% Mise en page
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\itshape \textcolor{gris}{Vyking - lexing et parsing}}
\lfoot{\itshape \textcolor{gris}{INFO-0085 Compilateurs}}
\cfoot{}
\rfoot{\itshape \textcolor{gris}{\thepage}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\newpage 

\section{Introduction}

classes 
endmarker
    générateur
    
\section{Trois versions de Vyking}
    Pour séparer les difficultés dans la compilation du langage, nous travaillerons sur trois versions successives du langage.
    La première, \emph{basic\_vyking} n'implémente que les fonctions de bases, le noyau du langage.
    La deuxième, \emph{listed\_vyking} rajoute les listes et les opérateurs de liste.
    La troisième et dernière version \emph{full\_vyking} implémentera les closures.
    
\section{Choix des outils}
    Nous avons isolé quelques lexer/parser dans la multitudes des outils disponibles.
    
    \paragraph{ANTLR}
        ANTLR est capable de générer du code Python pour le Parser, il dispose de beaucoup de documentation.
        L'analyse est top-down, ce qui rend la génération d'erreur plus facile.
        Cependant il vise les grammaires LL, nous ne voulions passer trop de temps à modifier la grammaire.
        De plus, en lisant sur le web, il apparait que le code généré cause beaucoup d'appels de fonctions\cite{antlr_ply_pyparsing}.
        Les appels sont bon marché en Java, le langage de base de ANTLR mais les appels sont chers en Python. 
        D'autres outils sont plus efficaces et orientés Python.
        
    \paragraph{Plex}
        Plex est assez populaire mais cet outil ne fait que l'analyse lexicale.
        Nous préférons une solution intégrée pour ne pas devoir apprendre deux outils.
        
    \paragraph{PLY}
        PLY est une implémentation de lex et yacc pour Python.
        PLY est programmé en Python pur, il n'est pas construit sur un noyau C.
        Cette approche le rend plus lent que les outils construit en C mais il est plus efficace (en temps et espace)\cite{PLYtalk} que tous les autres librairies Python.
        Il existe beaucoup de ressources en ligne et l'outil fournit des outils de diagnostique.
        Le report d'erreur était un des objectifs de développement pour PLY.        
        D'un point de vue pédagogique, nous avons retenu ce choix car il nous permet de nous familiariser avec Lex et Yacc tout en conservant une approche \emph{pythonesque}.
        
    \paragraph{} Nous avons retenu PLY. 
        Une introduction est disponible ici \url{http://www.dabeaz.com/ply/ply.html}.
        
        
\section{L'indentation}    
    Dans une syntaxe à la python, les espaces ne sont significatifs qu'en début de ligne et servent à délimiter les blocs.
    L'indentation est représentée par les tokens \verb WS  dont la valeur est le nombre d'espaces en début de ligne.
    
    \subsection{Lexing de l'indentation}
    Le lexer peut être dans deux états : \emph{initial} ou \emph{bol} (beginning of line).
    L'état \verb bol  est enclenché quand le lexer lit un retour à la ligne.
    Une fois dans l'état \verb bol , 3 actions sont possibles : 
    \begin{enumerate}
    \item Lecture d'espace(s) : le token \verb INDENT  est émis, sa valeur est le nombre d'espaces.
    \item Lecture d'un retour à la ligne, le lexer reste dans l'état \verb bol .
    \item Lecture d'un autre caractère, retour à l'état précédent.
    \end{enumerate}
    Les transitions sont illustrées à la figure \ref{lexing_state_machine}.   

    \begin{figure}
    \includegraphics[width=\textwidth]{lexing_state_machine.pdf}
    \caption{Machine d'état du lexer}
    \label{lexing_state_machine}
    \end{figure}
 
    \subsection{Délimitation des blocs}
    Dans la grammaire, les blocs sont délimités par les token \verb INDENT  et \verb DEDENT .
    La classe \emph{IndentFilter}  se place entre le lexer et le parser, son rôle est d'insérer des \verb INDENT  et des \verb DEDENT  dans le flux de token. 
    La grammaire requiert un bloc indenté après les instructions composées (\emph{compound statement}).
    Une instruction composée et son bloc sont séparés par un ":" (\verb COLON )
    La grammaire est la suivante :
    \begin{eqnarray*}    
    compound\_statement &::=& statement\_name ~ COLON ~ suite\\
    suite &::=& simple\_statement\\
          &|& INDENT ~ statement\_sequence ~ DEDENT\\    
    \end{eqnarray*}
    Les niveaux d'indentation sont mémorisés sur une pile "\emph{levels}".
    Les machines d'états sont illustrées à la figure \ref{filter}, page \pageref{filter}.
    
    \subsubsection*{Génération des INDENT}
        Le filtre peut être dans 3 états : 
        \begin{itemize}
        \item NO\_INDENT : \emph{IndentFilter} n'attend pas d'indentation. 
        Si le niveau d'indentation augmente, c'est une erreur, si le niveau d'indentation diminue, il faut insérer des \verb DEDENT .
        Quand le filtre reçoit un \verb COLON , on passe à l'état MAY\_INDENT.
        \item MAY\_INDENT : si \verb suite  est une instruction simple (sur une seule ligne), on retourne à l'état NO\_INDENT. Si on lit un \verb NEWLINE  on passe à l'état MUST\_INDENT.
        \item MUST\_INDENT : \emph{IndentFilter} attend un \verb WS  dont le niveau d'indentation est plus haut que le niveau courant, si c'est le cas, \emph{IndentFilter} génère un \verb INDENT  et retourne à l'état NO\_INDENT.
        Si il n'y a pas de bloc indenté, on lève une erreur.
        \end{itemize}
    
    \subsubsection{Génération des DEDENT}
        Quand \emph{IndentFilter} lit un \verb WS  dont la valeur est inférieure au niveau courant, 
        il génére des \verb DEDENT  tant que le niveau au sommet de la pile n'est pas le même que celui de \verb WS .
        Les états NO\_INDENT et NEED\_DEDENT ne sont pas explicites dans le code.

     \begin{figure}
    \includegraphics[width=\textwidth]{filter.pdf}
    \caption{Machine d'état de \emph{IndentFilter}. "WS.val" représente le nombre d'espaces lu en début de ligne. "level" est le niveau courant d'indentation.}
    \label{filter}
    \end{figure}

\section{Parsing}
\subsection*{if ... elif ... else}
dangling statement dont need mewline (dedent jour leur role)

precedence empty < else < elif

\section{Gestion des erreurs}
explication

\subsection*{detection}
    missing colon
    indentation error
\subsection*{fixing}

missing line at end of file
indentation problems


\section{Remarques}
    Les 3 étapes lexing, filtre et parsing sont découplées.
    Mais grâce à l'utilisation de générateur/itérateurs pour construire les classes \verb Lexer  et \verb IndentFilter , l'exécution du code ne nécessite qu'un parcours du texte.
    En effet, au lieu de passer tout le programme dans le \verb Lexer  et de conserver tous les tokens en mémoire, puis de faire un passe complet à travers le filtre, le \verb Lexer génère les tokens un à un et le filtre ajoute les \verb INDENTs   et \verb DEDENTs  au vol.
    
\bibliography{vyking_bib}
\bibliographystyle{plain}

\end{document}	





















